Pro Git
===========

`英文版 <http://git-scm.com/book>`_ ， `中文版 <http://git-scm.com/book/zh>`_

起步
--------

分布式版本控制系统的客户端并不只是提取最新版本的文件快照，而是把代码仓库完整地镜像下来。
这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。
因此每一次提取操作，实际上都是一次对代码仓库的完整备份。

Git基础
^^^^^^^^^^

**直接记录快照，而非差异比较**

Git和其他版本控制系统的主要差别在于，Git只关心文件数据的整体是否发生变化，而大多数其他系统
则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，Bazaar等）每次记录有哪些文件
作个更新，以及都更新了哪些行的什么内容。如下图所示：

.. image:: /_static/pics/save_diff.png

Git并不保存这些前后变化的差异数据。实际上，Git更像是把变化的文件作快照后，记录在一个微型的文件系统中。
每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件作一快照，然后保存一个指向这一次快照的索引。
为提高性能，若文件没有变化，Git不会再次保存，而只对上次保存的快照作一链接。Git的工作方式如下图所示：

.. image:: /_static/pics/git_snapshot_way.png

**近乎所有操作都是本地执行**

**时刻保持数据完整性**

在保存到Git之前，所有数据都要进行内容的校验和（checksum）计算，并将结果作为数据的唯一标识和索引。换句话说，
不可能在你修改了文件或目录之后，Git一无所知。所以如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，
Git都能立即察觉。

Git使用SHA-1算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个SHA-1哈希值，作为指纹字符串。该字串
由40个十六进制字符组成。Git的工作完全依赖于这类指纹字符串，所以你会经常看到这样的哈希值。实际上，所有保存在
Git数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。

**多数操作仅添加数据**

**文件的三种状态**

对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。
已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；
已暂存表示把已修改的文件放在下次提交时要保存的清单中。

每个项目都有一个 Git 目录（译注：如果 git clone 出来的话，就是其中 .git 的目录；如果 git clone --bare 的话，新建的目录本身就是 Git 目录。），它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，**每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据**。

从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。

所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。

安装 Git
^^^^^^^^^^

**从源代码安装**

Git 的工作需要调用 curl，zlib，openssl，expat，libiconv 等库的代码，所以需要先安装这些依赖工具。

初次运行Git前的配置
^^^^^^^^^^^^^^^^^^^^

一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。

Git 提供了一个叫做 git config 的工具（译注：实际是 ``git-config`` 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：

- ``/etc/gitconfig`` 文件：系统中对所有用户都普遍适用的配置。若使用 ``git config`` 时用 ``--system`` 选项，读写的就是这个文件。
- ``~/.gitconfig`` 文件：用户目录下的配置文件只适用于该用户。若使用 ``git config`` 时用 ``--global`` 选项，读写的就是这个文件。
- 当前项目的 git 目录中的配置文件（也就是工作目录中的 ``.git/config`` 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 ``.git/config`` 里的配置会覆盖 ``/etc/gitconfig`` 中的同名变量。

在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。

**用户信息**

第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：

::

    $ git config --global user.name "John Doe"
    $ git config --global user.email johndoe@example.com

如果用了 ``--global`` 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 ``--global`` 选项重新配置即可，新的设定保存在当前项目的 ``.git/config`` 文件里。

**文本编辑器**

Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：

::

    $ git config --global core.editor emacs

**差异分析工具**

在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：

::

    $ git config --global merge.tool vimdiff

Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具。

**查看配置信息**

要检查已有的配置信息，可以使用 ``git config --list`` 命令。

有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。

也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：

::

    $ git config user.name
    Scott Chacon

Git基础
---------

**忽略某些文件**

文件 ``.gitignore`` 的格式规范如下：

- 所有空行或者以注释符号 ``#`` 开头的行都会被Git忽略。
- 可以使用标准的glob模式匹配。
- 匹配模式最后跟反斜杠（ ``/`` ）说明要忽略的是目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加惊叹号（ ``!`` ）取反。

所谓的glob模式是指shell所使用的简化了的正则表达式。星号（ ``*``
）匹配零个或多个任意字符； ``[abc]``
匹配任何一个列在方括号中的字符（这个例子要么匹配一个a，要么匹配一个b，要么匹配一个c）；
问号（ ``?``
）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。

``.gitignore`` 示例：

::

    # 此为注释 – 将被 Git 忽略
    # 忽略所有 .a 结尾的文件
    *.a
    # 但 lib.a 除外
    !lib.a
    # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
    /TODO
    # 忽略 build/ 目录下的所有文件
    build/
    # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
    doc/*.txt

**查看已暂存和未暂存的更新**

要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 ``git diff`` 。

此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没暂存
起来的变化内容。


若要查看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 ``git diff --cached``
命令。

**跳过使用暂存区域**

尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了
一个跳过使用暂存区域的方式，只要在提交的时候，给 ``git commit`` 加上 ``-a``
选项，Git就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 ``git add``
步骤。

**移除文件**

如果我们想把文件从Git仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。
换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 ``.a`` 编译文件，不小心
纳入仓库后，要移除跟踪但不删除文件，以便稍后在 ``.gitignore`` 文件中补上，
用 ``--cached`` 选项即可：

::

    $ git rm --cached readme.txt

后面可以列出文件或者目录的名字，也可以使用glob模式，如：

::

    $ git rm log/\*.log

撤销操作
^^^^^^^^^^^

**修改最后一次提交**

有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤销刚才的提交操作，
可以使用 ``--amend`` 选项重新提交：

::

    $ git commit --amend

此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令
的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。

启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的
提交说明覆盖刚才失误的提交。

如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 ``--amend``
提交：

::

    $ git commit -m 'initial commit'
    $ git add forgotten_file
    $ git commit --amend

上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。

**取消已经暂存的文件**

::

    $ git reset HEAD <file>

**取消对文件的修改**

::

    $ git checkout -- <file>

记住，任何已经提交到Git的都可以被恢复。即便在已经删除的分支中的提交，
或者用 ``--amend`` 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。
所以，你可能失去的数据，仅限于没有提交过的，对Git来说它们就像从未存在过一样。

远程仓库的使用
^^^^^^^^^^^^^^^^^^

**查看当前的远程库**

要查看当前配置有哪些远程仓库，可以用 ``git remote``
命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为origin的远程库，
Git默认使用这个名字来标识你所克隆的原始仓库。

也可以加上 ``-v`` 选项，显示对应的克隆地址：

::

    $ git remote -v
    origin  git://github.com/schacon/ticgit.git

**添加远程仓库**

要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 ``git remote
add [shortname] [url]`` 。

**查看远程仓库信息**

我们可以使用命令 ``git remote show <remote-name>``
来查看某个远程仓库的详细信息。

**远程仓库的删除和重命名**

在新版Git中可以用 ``git remote rename`` 命令修改某个远程仓库在本地的简称，
比如想把 ``pb`` 改成 ``paul`` ，可以这么运行：

::

    $ git remote rename pb paul
    $ git remote
    origin
    paul


碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，
那么需要移除对应的远端仓库，可以运行 ``git remote rm`` 命令：

::

    $ git remote rm paul
    $ git remote
    origin

打标签
^^^^^^^

**列出已有的标签**

直接运行 ``git tag`` 即可。

显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。

**新建标签**

Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个
指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件
地址和日期，以及标签说明，标签本身也允许使用GNU Privary Guard（GPG）来签署或炎症。一般我们建议使用含附注型的标签，以便
保留相关信息。如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签页没问题。

**含附注的标签**

创建一个含附注类型的标签非常简单，用 ``-a`` （取 ``annotated`` 的首字母）指定标签名字即可：

::

    $ git tag -a v1.4 -m "my version 1.4"
    $ git tag
    v0.1
    v1.3
    v1.4

而 ``-m`` 选项则指定了对应的标签说明，Git会将此说明一同保存在标签对象中。如果没有给出该选项，Git会启动文本编辑软件供你
输入标签说明。

可以使用 ``git show`` 命令查看相应的标签的版本信息，并连同显示打标签时的提交对象。

**签署标签**

如果你有自己的私钥，还可以用GPG来签署标签，只需要把之前的 ``-a`` 改为 ``-s`` （取 ``signed`` 的首字母）即可。

**轻量级标签**

轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签， ``-a`` ， ``-s`` 或 ``-m`` 选项都不用，
直接给出标签名字即可：

::

    $ git tag v1.4-lw
    $ git tag
    v0.1
    v1.3
    v1.4
    v1.4-lw
    v1.5

**验证标签**

可以使用 ``git tag -v [tag-name]`` （取 ``verify`` 的首字母）的方式验证已经签署的标签。此命令会调用GPG来验证签名，所以你
需要有签署者的公钥，存放在keyring中，才能验证。

**后期加注标签**

可以在后期对早先的某次提交加注标签。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：

::

    $ git tag -a v1.2 9fceb02

**分享标签**

默认情况下， ``git push`` 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，
运行 ``git push origin [tagname]`` 即可。

如果要一次推送所有本地新增的标签上去，可以使用 ``--tags`` 选项。

现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。

技巧和窍门
^^^^^^^^^^^^^

**自动补全**

如果你用的是Bash shell，可以试试看Git提供的自动补全脚本。下载Git源码，进入 ``contrib/completion`` 目录，会看到一个
``git-completion.bash`` 文件。将此文件复制为你自己的用户主目录中的 ``.git-completion.bash`` 文件，并把下面一行内容添加到
你的 ``.bashrc`` 文件中：

::

    source ~/.git-completion.bash

如果在Windows上安装了msysGit，默认使用的Git Bash就已经配好了这个自动补全脚本，可以直接使用。

**Git命令别名**

Git并不会推断你输入的几个字符将会是哪条命令。如果想偷懒，少输入几个命令的字符，可以使用 ``git config`` 为命令设置别名。
例如：

::

    $ git config --global alias.co checkout
    $ git config --global alias.br branch
    $ git config --global alias.ci commit
    $ git config --global alias.st status

现在，如果要输入 ``git commit`` 只需键入 ``git ci`` 即可。

使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐，可以自己设置一下：

::

    $ git config --global alias.unstage 'reset HEAD --'     # 这里的reset HEAD -- 为什么不是reset HEAD？

这样一来，下面的两条命令完全等同：

::

    $ git unstage fileA
    $ git reset HEAD fileA

显然，使用别名的方式看起来更清楚。另外，我们还经常设置 ``last`` 命令：

::

    $ git config --global alias.last 'log -1 HEAD'

然后要看最后一次的提交信息，就变得简单多了：

::

    $ git last

可以看出，实际上Git只是简丹地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非Git的子命令，这个好办，
只需要在命令前加上 ``!`` 就行。如果你自己写了些处理Git仓库信息的脚本的话，就可以使用这种技术包装起来，例如设置 ``git visual``
启动 ``gitk`` 。

::

    $ git config --global alias.visual '!gitk'

Git分支
----------

和许多其他版本控制系统不同，Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。

何谓分支
^^^^^^^^^^^

在Git中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含
零个或多个指向该提交对象的父对象指针：首次提交时没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多
个祖先。

暂存操作会对每一个要暂存的文件（确实发生变更或新增文件）计算校验和，然后把当前版本的文件快照保存到Git仓库中（Git使用blob
类型的对象存储这些快照），并将校验和加入暂存区域：

::

    $ git add README test.rb LICENCE
    $ git commit -m 'initial commit of my project'

当使用 ``git commit`` 新建一个提交对象前，Git会先计算每一个子目录的校验和，然后在Git仓库中将这些目录保存为树（tree）对象。
之后Git创建的提交对象，除了包含相关提交信息以外，还包含着指向这个树对象的指针，如此它就可以在将来需要的时候，重现此次快照
的内容了。

现在，Git仓库中有五个对象：三个表示文件快照内容的blob对象；一个记录着目录树内容及其中各个文件对应blob对象索引的tree对象；
以及一个包含指向tree对象（根目录）的索引和其他提交信息元数据的commit对象。

